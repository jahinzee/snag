#!/usr/bin/env python

"""
snag
A super-simple down-to-the-wire "framework" for building websites with shell scripts.
"""

__author__ = "jahinzee"
__license__ = "GPLv2"
__version__ = "1.3"
__email__ = "jahinzee@outlook.com"

import subprocess, re, os, yaml, sys, tabulate, glob
from bs4 import BeautifulSoup
import htmlmin

class Snag:

    raw_text: str
    args: str = []
    stdin: str
    output: str

    def __init__(self, _raw: str, _args: str, _stdin: str) -> None:

        self.raw_text = _raw
        self.args = _args
        self.stdin = _stdin

    def parse(self) -> str:

        # load process from args
        output = ""
        try:

            if not os.access(self.args[0], os.X_OK):
                os.chmod(self.args[0], 0o700)
            
            proc = subprocess.Popen(self.args,
                                    stdin=subprocess.PIPE,
                                    stdout=subprocess.PIPE, text=True)
            (output, err) = proc.communicate(input=self.stdin)

        except subprocess.SubprocessError as ex:

            # subprocess error
            Errors.raise_error(f"Subprocess error -- {ex}")

        except FileNotFoundError:

            # can't find file
            Errors.raise_error(f"Cannot find process or file \"{self.args[0]}\".")

        except PermissionError:

            # permission issue
            Errors.raise_error(f"You do not have permissions for \"{self.args[0]}\".")


        # POST: output == output of command from args

        self.output = output
        return output

    def debug(self) -> None:

        # the most *pain*ful one-liner you'll ever see
        Debug.print_table("Snag", [["Raw Text", re.sub(r'\s+', ' ', self.raw_text)], ["Command", (' '.join(str(x) for x in map(lambda x: f"\"{x}\"" if bool(re.search(r"\s", x)) else x, self.args))) + (f" <<< \"{self.stdin}\"" if self.stdin is not None else "")]])

class Document:

    path: str
    raw_text: str
    processed_text: str

    def __init__(self, _path: str) -> str:

        self.path = _path

        # open file if possible
        self.raw_text = ""
        try:
            with open(self.path) as f:
                self.raw_text = f.read()
        except FileNotFoundError:
            Errors.raise_error(f"cannot find process or file \"{self.path}\".")
            
        self.raw_text = BeautifulSoup(self.raw_text, 'html.parser').prettify()

        # POST: raw text and path has been loaded
        
    def parse(self) -> None:

        soup = BeautifulSoup(self.raw_text, 'html.parser')
        temp = htmlmin.minify(self.raw_text, remove_empty_space=True)

        # load snags from doc
        for snag in soup.find_all("snag"):
            
             new_s = Snag(str(snag).strip(),                                               # raw tag text but without surrounding whitespace
                          list(dict(sorted(snag.attrs.items())).values()),                 # <snag a="eggs" b="spam"></snag> --> ["eggs", "spam"]
                          "" if len(snag.contents) == 0 else snag.contents[0].strip())     # tag contents; empty string if doesn't exist
             
             parsed = new_s.parse()
             
             # find and replace!             
             temp = temp.replace(htmlmin.minify(new_s.raw_text,             # htmlmin used to ensure that whitespace doesn't mess up the find-and-replace
                                                remove_empty_space=True),
                                 parsed)
            
        
        # final prettification
        temp = BeautifulSoup(temp, 'html.parser').prettify()

        # header?
        header_msg = Settings.get("header_msg")
        self.processed_text = (f"<!-- {header_msg} -->\n" if header_msg != "" else "") + temp

        # POST: processed_text contains properly swapped tags -> outputs
        return self.processed_text

    def debug(self) -> None:
        
        print(f"Filepath: {self.path}")
        print(":::: Snaglist")
        for s in self.snags:
            print(s.debug())
        
            

class Workspace:

    docs: Document = []
    src_dest: dict = {}

    def __init__(self):
        
        file_list = [f for f in glob.glob("./**/*", recursive=True) if os.path.isfile(f)]

        old_ext = Settings.get("input_ext")
        new_ext = Settings.get("output_ext")

        # load docs and set output extension
        for f in file_list:
            
            if f.lower().endswith(old_ext):
                self.src_dest[f] = f[:-len(old_ext)] + new_ext
                self.docs.append(Document(f))

    def parse(self):

        # parse all and write
        for d in self.docs:
            with open(self.src_dest[d.path], 'w') as out:
                out.write(d.parse())
                
    def debug(self):
        for d in self.docs:
            d.debug()

class Errors:

    def raise_common(msg, prefix):
        print(f"{prefix} {msg}", file=sys.stderr)

    def raise_warn(msg):
        Errors.raise_common(msg, "WARN:")
        
    def raise_info(msg):
        Errors.raise_common(msg, "INFO:")

    def raise_error(msg, errCode=1):
        Errors.raise_common(msg, "ERROR:")
        sys.exit(errCode)

class Debug:

    def print_table(title, t):
        print(f":: {title}\n" + tabulate.tabulate(t, tablefmt="plain"))

class Settings:

    _defaults: dict = {

        "input_ext"  : "htsg",
        "output_ext" : "html",
        "header_msg" : "autogenerated with snag"

    }
        
    def get(key: str):

        try:
            with open('snag_settings.yaml', 'r') as file:   
                settings = (yaml.safe_load(file))["snag"]
        except FileNotFoundError:
            Errors.raise_warn(f"could not load setting {key}, using default value.")
            settings = {}

        return settings[key] if key in settings else Settings._defaults[key]

    def make():
        with open('snag_settings.yaml', 'w') as file:
            file.write(yaml.dump({ "snag" : Settings._defaults }, allow_unicode=True))

if __name__ == "__main__":

    if "--help" in sys.argv:
        print("Usage: snag [--help | --settings]", file=sys.stderr)
        sys.exit()

    if "--settings" in sys.argv:
        Settings.make()
        print("Created snag_settings.yaml.", file=sys.stderr)
        sys.exit()
    
    wsp = Workspace()
    wsp.parse()
    
